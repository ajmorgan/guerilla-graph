//! Plan storage operations for Guerilla Graph.
//!
//! This module handles all plan-related CRUD operations:
//! - Plan creation, retrieval, listing, updates, deletion
//! - Plan summaries and execution tracking
//!
//! Uses SQL Executor to eliminate SQLite C API boilerplate.

const std = @import("std");
const c_imports = @import("c_imports.zig");
const c = c_imports.c;
const storage = @import("storage.zig");
const types = @import("types.zig");
const sql_executor = @import("sql_executor.zig");

/// Plan storage operations.
pub const PlanStorage = struct {
    executor: sql_executor.Executor,
    allocator: std.mem.Allocator,

    /// Initialize plan storage with executor.
    /// Rationale: Store executor by VALUE to avoid dangling pointers.
    /// When Storage.init() returns by value, pointers to its fields become invalid.
    pub fn init(executor: sql_executor.Executor, allocator: std.mem.Allocator) PlanStorage {
        const plan_storage = PlanStorage{
            .executor = executor,
            .allocator = allocator,
        };
        std.debug.assert(@intFromPtr(plan_storage.executor.database) != 0);

        return plan_storage;
    }

    // ========================================================================
    // Plan CRUD Operations
    // ========================================================================
    // Functions moved AS-IS from storage.zig (task 035)
    // Will be refactored to use executor in Phase 1+ (tasks 038-053)

    /// Create a new plan with unique slug, title, and description.
    /// Returns error if slug already exists.
    ///
    /// Rationale: Plans are top-level organizational containers for tasks.
    /// New plans start with status='open', no execution_started_at or completed_at timestamps.
    /// Slug is user-facing kebab-case identifier (e.g., "auth", "payments").
    pub fn createPlan(
        self: *PlanStorage,
        slug: []const u8,
        title: []const u8,
        description: []const u8,
        created_at: ?i64,
    ) !void {
        // Assertions: Validate inputs (Tiger Style: 2+ per function)
        std.debug.assert(slug.len > 0);
        std.debug.assert(slug.len <= types.MAX_PLAN_ID_LENGTH);
        // Note: title can be empty (optional), so no minimum length assertion
        std.debug.assert(title.len <= 500); // Enforced by CHECK constraint in schema

        // Rationale: Use provided timestamp or current time.
        const utils = @import("utils.zig");
        const timestamp = created_at orelse utils.unixTimestamp();
        std.debug.assert(timestamp > 0);

        // Rationale: Insert plan with slug, task_counter=0, and timestamps.
        // If created_at is provided, use it; otherwise use current time.
        // New plans start with status='open', no execution_started_at or completed_at timestamps.
        // id (INTEGER PRIMARY KEY) is auto-generated by SQLite.
        const sql =
            \\INSERT INTO plans (slug, title, description, status, task_counter, created_at, updated_at, execution_started_at, completed_at)
            \\VALUES (?, ?, ?, 'open', 0, ?, ?, NULL, NULL)
        ;

        try self.executor.exec(sql, .{ slug, title, description, timestamp, timestamp });

        // Assertion: Plan inserted successfully (exec completes without error)
        std.debug.assert(slug.len > 0);
    }

    /// Get plan summary with task counts by status.
    /// Returns PlanSummary with aggregated task counts, or null if plan not found.
    /// Caller is responsible for freeing the returned PlanSummary via deinit().
    ///
    /// Rationale: Uses LEFT JOIN to include plans even with zero tasks.
    /// COUNT and SUM provide task counts by status in a single query.
    /// This is more efficient than separate queries for each status.
    /// Lookup by slug (user-facing identifier) instead of internal INTEGER id.
    pub fn getPlanSummary(self: *PlanStorage, slug: []const u8) !?types.PlanSummary {
        // Assertions: Validate inputs
        std.debug.assert(@intFromPtr(self.executor.database) != 0);
        std.debug.assert(slug.len > 0);
        std.debug.assert(slug.len <= types.MAX_PLAN_ID_LENGTH);

        const sql =
            \\SELECT
            \\    p.id, p.slug, p.title, p.description, p.status,
            \\    p.created_at, p.execution_started_at, p.completed_at, p.task_counter,
            \\    COUNT(t.id) as total_tasks,
            \\    SUM(CASE WHEN t.status = 'completed' THEN 1 ELSE 0 END) as completed_tasks,
            \\    SUM(CASE WHEN t.status = 'in_progress' THEN 1 ELSE 0 END) as in_progress_tasks,
            \\    SUM(CASE WHEN t.status = 'open' THEN 1 ELSE 0 END) as open_tasks
            \\FROM plans p
            \\LEFT JOIN tasks t ON t.plan_id = p.id
            \\WHERE p.slug = ?
            \\GROUP BY p.id, p.slug, p.status, p.created_at, p.execution_started_at, p.completed_at, p.task_counter
        ;

        // Rationale: Define row struct matching SQL column types.
        // Status is extracted as string and converted to enum after query.
        // Task counts use i64 from SQLite, will be cast to u32 after validation.
        // Now includes both id (INTEGER) and slug (TEXT).
        const PlanSummaryRow = struct {
            id: i64,
            slug: []const u8,
            title: []const u8,
            description: []const u8,
            status: []const u8,
            created_at: i64,
            execution_started_at: ?i64,
            completed_at: ?i64,
            task_counter: i64,
            total_tasks: i64,
            completed_tasks: i64,
            in_progress_tasks: i64,
            open_tasks: i64,

            pub fn deinit(row: *@This(), allocator: std.mem.Allocator) void {
                allocator.free(row.slug);
                allocator.free(row.title);
                allocator.free(row.description);
                allocator.free(row.status);
            }
        };

        // Rationale: Use executor.queryOne() to eliminate SQLite C API boilerplate.
        // Returns null if plan not found (SQLITE_DONE case).
        const row_opt = try self.executor.queryOne(PlanSummaryRow, self.allocator, sql, .{slug});
        if (row_opt == null) return null;

        var row = row_opt.?;
        defer row.deinit(self.allocator);

        // Rationale: Convert status string to enum.
        const status = try types.TaskStatus.fromString(row.status);

        // Rationale: Cast SQLite i64 counts to u32 after validation.
        // Negative counts indicate data corruption.
        if (row.total_tasks < 0 or row.completed_tasks < 0 or
            row.in_progress_tasks < 0 or row.open_tasks < 0)
        {
            return storage.SqliteError.InvalidData;
        }

        const total_tasks: u32 = @intCast(row.total_tasks);
        const completed_tasks: u32 = @intCast(row.completed_tasks);
        const in_progress_tasks: u32 = @intCast(row.in_progress_tasks);
        const open_tasks: u32 = @intCast(row.open_tasks);

        // Assertion: Task counts sum to total (data consistency check)
        std.debug.assert(completed_tasks + in_progress_tasks + open_tasks == total_tasks);

        // Rationale: Transfer ownership of strings to PlanSummary.
        // Caller is responsible for calling deinit() on returned value.
        // Cast row.id (i64) to u32 for PlanSummary.id field.
        const plan_id: u32 = @intCast(row.id);

        // Assertion: created_at must be positive (Tiger Style).
        std.debug.assert(row.created_at > 0);

        return types.PlanSummary{
            .id = plan_id,
            .slug = try self.allocator.dupe(u8, row.slug),
            .title = try self.allocator.dupe(u8, row.title),
            .description = try self.allocator.dupe(u8, row.description),
            .status = status,
            .created_at = row.created_at,
            .execution_started_at = row.execution_started_at,
            .completed_at = row.completed_at,
            .task_counter = @intCast(row.task_counter),
            .total_tasks = total_tasks,
            .completed_tasks = completed_tasks,
            .in_progress_tasks = in_progress_tasks,
            .open_tasks = open_tasks,
        };
    }

    /// List all plans with optional status filter, including task summaries.
    /// Returns an array of PlanSummary sorted by creation time (oldest first).
    /// Caller is responsible for freeing the returned array and its contents via PlanSummary.deinit().
    pub fn listPlans(
        self: *PlanStorage,
        status_filter: ?types.TaskStatus,
    ) ![]types.PlanSummary {
        std.debug.assert(@intFromPtr(self.executor.database) != 0);

        const sql_base =
            \\SELECT p.id, p.slug, p.title, p.description, p.status, p.created_at, p.execution_started_at, p.completed_at, p.task_counter,
            \\    COUNT(t.id) as total_tasks,
            \\    SUM(CASE WHEN t.status = 'completed' THEN 1 ELSE 0 END) as completed_tasks,
            \\    SUM(CASE WHEN t.status = 'in_progress' THEN 1 ELSE 0 END) as in_progress_tasks,
            \\    SUM(CASE WHEN t.status = 'open' THEN 1 ELSE 0 END) as open_tasks
            \\FROM plans p LEFT JOIN tasks t ON t.plan_id = p.id
        ;
        const sql = if (status_filter != null)
            sql_base ++ " WHERE p.status = ? GROUP BY p.id, p.slug, p.status, p.created_at, p.execution_started_at, p.completed_at, p.task_counter ORDER BY p.created_at ASC"
        else
            sql_base ++ " GROUP BY p.id, p.slug, p.status, p.created_at, p.execution_started_at, p.completed_at, p.task_counter ORDER BY p.created_at ASC";

        const PlanSummaryRow = struct {
            id: i64,
            slug: []const u8,
            title: []const u8,
            description: []const u8,
            status: []const u8,
            created_at: i64,
            execution_started_at: ?i64,
            completed_at: ?i64,
            task_counter: i64,
            total_tasks: i64,
            completed_tasks: i64,
            in_progress_tasks: i64,
            open_tasks: i64,
            pub fn deinit(row: *@This(), allocator: std.mem.Allocator) void {
                allocator.free(row.slug);
                allocator.free(row.title);
                allocator.free(row.description);
                allocator.free(row.status);
            }
        };

        const rows = if (status_filter) |status|
            try self.executor.queryAll(PlanSummaryRow, self.allocator, sql, .{status.toString()})
        else
            try self.executor.queryAll(PlanSummaryRow, self.allocator, sql, .{});
        defer {
            for (rows) |*row| row.deinit(self.allocator);
            self.allocator.free(rows);
        }

        var plans = try self.allocator.alloc(types.PlanSummary, rows.len);
        errdefer {
            for (plans, 0..) |*plan, i| {
                if (i < rows.len) plan.deinit(self.allocator);
            }
            self.allocator.free(plans);
        }

        for (rows, 0..) |row, i| {
            if (row.total_tasks < 0 or row.completed_tasks < 0 or
                row.in_progress_tasks < 0 or row.open_tasks < 0)
                return storage.SqliteError.InvalidData;

            const plan_id: u32 = @intCast(row.id);
            const total_tasks: u32 = @intCast(row.total_tasks);
            const completed_tasks: u32 = @intCast(row.completed_tasks);
            const in_progress_tasks: u32 = @intCast(row.in_progress_tasks);
            const open_tasks: u32 = @intCast(row.open_tasks);
            std.debug.assert(completed_tasks + in_progress_tasks + open_tasks == total_tasks);

            // Assertion: created_at must be positive (Tiger Style).
            std.debug.assert(row.created_at > 0);

            plans[i] = types.PlanSummary{
                .id = plan_id,
                .slug = try self.allocator.dupe(u8, row.slug),
                .title = try self.allocator.dupe(u8, row.title),
                .description = try self.allocator.dupe(u8, row.description),
                .status = try types.TaskStatus.fromString(row.status),
                .created_at = row.created_at,
                .execution_started_at = row.execution_started_at,
                .completed_at = row.completed_at,
                .task_counter = @intCast(row.task_counter),
                .total_tasks = total_tasks,
                .completed_tasks = completed_tasks,
                .in_progress_tasks = in_progress_tasks,
                .open_tasks = open_tasks,
            };
        }

        return plans;
    }

    /// Resolve user-facing slug to internal INTEGER plan ID.
    /// Returns error if slug doesn't exist.
    ///
    /// Rationale: Helper function for internal operations that need INTEGER plan_id.
    /// Used by task_storage.zig when creating tasks with --plan flag.
    /// Slug is indexed for fast lookups (UNIQUE constraint on slug column).
    pub fn getPlanIdFromSlug(self: *PlanStorage, slug: []const u8) !u32 {
        // Assertions: Validate inputs
        std.debug.assert(@intFromPtr(self.executor.database) != 0);
        std.debug.assert(slug.len > 0);
        std.debug.assert(slug.len <= types.MAX_PLAN_ID_LENGTH);

        const sql = "SELECT id FROM plans WHERE slug = ?";

        const IdRow = struct {
            id: i64,
        };

        const row = try self.executor.queryOne(IdRow, self.allocator, sql, .{slug});
        if (row == null) {
            return storage.SqliteError.InvalidData; // Plan not found
        }

        // Rationale: Convert i64 to u32 for plan_id.
        // SQLite INTEGER PRIMARY KEY is i64, but we expect plan IDs in u32 range.
        if (row.?.id < 0) {
            return storage.SqliteError.InvalidData;
        }

        const plan_id: u32 = @intCast(row.?.id);

        // Assertion: Valid plan ID returned
        std.debug.assert(plan_id > 0);

        return plan_id;
    }

    /// Update plan execution_started_at timestamp and status to 'in_progress'.
    /// Idempotent: no error if plan already started (0 rows updated).
    ///
    /// Rationale: Mark plan execution start. Only sets timestamp if NULL (first start only).
    /// This supports idempotent workflow commands.
    pub fn updatePlanExecutionStarted(self: *PlanStorage, slug: []const u8) !void {
        // Assertions: Validate inputs (Tiger Style: 2+ per function)
        std.debug.assert(@intFromPtr(self.executor.database) != 0);
        std.debug.assert(slug.len > 0);
        std.debug.assert(slug.len <= types.MAX_PLAN_ID_LENGTH);

        // Rationale: Get current timestamp for execution_started_at and updated_at fields.
        // Using utils.unixTimestamp() for consistency with other timestamp handling.
        const utils = @import("utils.zig");
        const current_timestamp = utils.unixTimestamp();

        // Rationale: Update plan status to 'in_progress' and set timestamps.
        // WHERE clause ensures: plan exists and not already started.
        // execution_started_at IS NULL ensures idempotent behavior (only set once).
        // Idempotent: no error if 0 rows updated (plan already started or doesn't exist).
        const sql =
            \\UPDATE plans SET execution_started_at=?, status='in_progress', updated_at=? WHERE slug=? AND execution_started_at IS NULL
        ;

        try self.executor.exec(sql, .{ current_timestamp, current_timestamp, slug });

        // Assertion: Update executed successfully (idempotent - 0 or more rows updated)
        std.debug.assert(@intFromPtr(self.executor.database) != 0);
    }

    /// Check if plan exists before attempting update.
    /// Returns error if plan doesn't exist, void on success.
    ///
    /// Rationale: Extracted from updatePlan to reduce function length.
    /// Provides better error messages than silent UPDATE affecting 0 rows.
    fn updatePlanCheckExists(
        self: *PlanStorage,
        slug: []const u8,
    ) !void {
        // Assertions: Validate inputs
        std.debug.assert(slug.len > 0);

        const check_sql = "SELECT COUNT(*) as count FROM plans WHERE slug = ?";

        const CountRow = struct {
            count: i64,
        };

        const row = try self.executor.queryOne(CountRow, self.allocator, check_sql, .{slug});
        if (row == null or row.?.count == 0) {
            return storage.SqliteError.InvalidData; // Plan not found
        }

        // Assertion: Plan exists
        std.debug.assert(row.?.count > 0);
    }

    /// Update plan fields (title and/or description).
    /// At least one field must be non-null.
    ///
    /// Rationale: Allows modifying plan metadata after creation.
    /// updates the updated_at timestamp automatically.
    /// Validates that plan exists before attempting update.
    pub fn updatePlan(self: *PlanStorage, slug: []const u8, title: ?[]const u8, description: ?[]const u8) !void {
        // Assertions: Validate inputs (Tiger Style: 2+ per function)
        std.debug.assert(@intFromPtr(self.executor.database) != 0);
        std.debug.assert(slug.len > 0);
        std.debug.assert(slug.len <= types.MAX_PLAN_ID_LENGTH);
        std.debug.assert(title != null or description != null); // At least one field to update

        // Check if plan exists before updating
        try self.updatePlanCheckExists(slug);

        // Rationale: Get current timestamp for updated_at field.
        const utils = @import("utils.zig");
        const current_timestamp = utils.unixTimestamp();

        // Rationale: Build UPDATE statement based on which fields are provided.
        // Use static SQL strings for each combination - there are only 3 cases.
        // Executor handles prepare/bind/step/finalize lifecycle.
        if (title != null and description != null) {
            const sql = "UPDATE plans SET title = ?, description = ?, updated_at = ? WHERE slug = ?";
            try self.executor.exec(sql, .{ title.?, description.?, current_timestamp, slug });
        } else if (title) |t| {
            const sql = "UPDATE plans SET title = ?, updated_at = ? WHERE slug = ?";
            try self.executor.exec(sql, .{ t, current_timestamp, slug });
        } else { // description != null (guaranteed by assertion above)
            const sql = "UPDATE plans SET description = ?, updated_at = ? WHERE slug = ?";
            try self.executor.exec(sql, .{ description.?, current_timestamp, slug });
        }

        // Assertion: At least one field was updated
        std.debug.assert(title != null or description != null);
    }

    /// Count tasks for a given plan (by slug).
    /// Returns the number of tasks associated with the plan.
    /// Private helper function for deletePlan().
    ///
    /// Returns: Non-negative task count (i64)
    ///
    /// Rationale: Extracted to keep deletePlan() closer to 70-line guideline.
    /// Query is fast (<1ms) and provides user feedback about deletion scope.
    /// Refactored to use executor.queryOne() to eliminate C API boilerplate.
    /// Uses slug lookup with JOIN to plan table.
    fn countTasksForPlan(self: *PlanStorage, slug: []const u8) !i64 {
        // Assertions: Validate inputs
        std.debug.assert(slug.len > 0);

        const count_tasks_sql =
            \\SELECT COUNT(*) as count FROM tasks t
            \\INNER JOIN plans p ON t.plan_id = p.id
            \\WHERE p.slug = ?
        ;

        const CountRow = struct {
            count: i64,
        };

        const row = try self.executor.queryOne(CountRow, self.allocator, count_tasks_sql, .{slug});
        if (row == null) {
            // No row returned means error in query - should not happen for COUNT(*)
            return storage.SqliteError.StepFailed;
        }

        const task_count = row.?.count;

        // Assertion: SQLite COUNT() always returns non-negative
        std.debug.assert(task_count >= 0);

        return task_count;
    }

    /// Delete a plan and cascade delete all associated tasks.
    /// Returns the number of tasks that were deleted.
    /// Returns error if plan doesn't exist.
    ///
    /// Rationale: Uses ON DELETE CASCADE to automatically remove all tasks
    /// and their dependencies when a plan is deleted. Wrapped in transaction
    /// for atomicity. Returns task count for user feedback.
    /// Refactored to use executor for queries and local transaction helpers.
    pub fn deletePlan(self: *PlanStorage, slug: []const u8) !u64 {
        // Assertions: Validate inputs (Tiger Style: 2+ per function)
        std.debug.assert(@intFromPtr(self.executor.database) != 0);
        std.debug.assert(slug.len > 0);
        std.debug.assert(slug.len <= types.MAX_PLAN_ID_LENGTH);

        // Rationale: Begin transaction to ensure atomic deletion of plan and all tasks.
        // If any step fails, rollback ensures database remains consistent.
        try self.executor.beginTransaction();
        errdefer self.executor.rollback();

        // Rationale: Check if plan exists before attempting delete.
        // Using executor.queryOne() to eliminate C API boilerplate.
        const check_plan_sql = "SELECT COUNT(*) as count FROM plans WHERE slug = ?";

        const CountRow = struct {
            count: i64,
        };

        const row = try self.executor.queryOne(CountRow, self.allocator, check_plan_sql, .{slug});
        if (row == null or row.?.count == 0) {
            return storage.SqliteError.InvalidData; // Plan not found
        }

        // Assertion: Plan exists
        std.debug.assert(row.?.count > 0);

        // Rationale: Count tasks before deletion to inform user in CLI output.
        // This is informational only - we no longer prevent deletion.
        const task_count = try self.countTasksForPlan(slug);

        // Rationale: Delete the plan (CASCADE will automatically delete tasks).
        // Using executor.exec() to eliminate C API boilerplate.
        const delete_sql = "DELETE FROM plans WHERE slug = ?";
        try self.executor.exec(delete_sql, .{slug});

        // Assertion: Delete executed successfully (no error thrown)
        std.debug.assert(@intFromPtr(self.executor.database) != 0);

        // Rationale: Commit transaction after successful deletion.
        // SQLite's ON DELETE CASCADE will have already deleted tasks and dependencies.
        try self.executor.commit();

        // Rationale: Return task count for CLI to display.
        // Cast from i64 to u64 (count is always non-negative).
        return @intCast(task_count);
    }
};
